const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const fs = require('file-system');
import mongoose, { Document, Schema } from 'mongoose';

if (!process.env.JWT_SECRET_PATH) {
  // No secret, we cannot proceed
  // TODO: need a better way to handle these fatal errors
  // console.log might not get printed
  console.log('Error: JWT_SECRET_PATH environment variable needs to be set');
  process.exit(1);
}
// Needs to be a 256 bit priv key generated by openssl
const priv_key = fs.readFileSync(process.env.JWT_SECRET_PATH, 'utf8');

export interface IUser extends Document {
  username: string;
  pw_hash: string;
  pw_salt: string;
  generateToken: Function;
  setPassword: Function;
  isCorrectPassword: Function;
}

const userSchema: Schema = new Schema({
  username: {
    type: String,
    unique: true,
    required: true
  },
  pw_hash: {
    type: String,
    required: true
  },
  pw_salt: {
    type: String,
    required: true
  }
});

userSchema.methods.setPassword = function(password: string) {
  this.pw_salt = crypto.randomBytes(16).toString('hex');
  this.pw_hash = crypto
    .pbkdf2Sync(
      Buffer.from(password, 'binary'),
      Buffer.from(this.pw_salt, 'binary'),
      1000,
      64,
      'sha256'
    )
    .toString('hex');
};

userSchema.methods.isCorrectPassword = function(password: string) {
  const hash = crypto
    .pbkdf2Sync(
      Buffer.from(password, 'binary'),
      Buffer.from(this.pw_salt, 'binary'),
      1000,
      64,
      'sha256'
    )
    .toString('hex');
  return this.pw_hash === hash;
};

// TODO: Need to include more uniqueness in the payload to make it more secure
userSchema.methods.generateToken = function() {
  return jwt.sign(
    {
      _id: this._id,
      username: this.username
    },
    priv_key,
    {
      algorithm: 'ES256',
      expiresIn: '7 days'
    }
  );
};

export default mongoose.model<IUser>('User', userSchema);
