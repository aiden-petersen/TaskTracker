const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const fs = require('file-system');
import mongoose, { Document, Schema } from 'mongoose';

if(!process.env.JWT_SECRET_PATH)
{
    // No secret, we cannot proceed
    // TODO: need a better way to handle these fatal errors
    // console.log might not get printed
    console.log("Error: JWT_SECRET_PATH environment variable needs to be set");
    process.exit(1);
}
// Needs to be a 256 bit priv key generated by openssl
const priv_key = fs.readFileSync(process.env.JWT_SECRET_PATH, 'utf8');

export interface IUser extends Document {
    username: string;
    pw_hash: string;
    pw_salt: string;
    generateToken: Function;
    setPassword: Function;
    isCorrectPassword: Function;
}

const userSchema: Schema = new Schema({
    username: {
        type: String,
        unique: true,
        required: true
    },
    pw_hash: {
        type: String,
        required: true
    },
    pw_salt: {
        type: String,
        required: true
    }
});

userSchema.methods.setPassword = function(password: string){
    this.pw_salt = crypto.randomBytes(16).toString('hex');
    this.pw_hash = crypto.pbkdf2Sync(Buffer.from(password, 'binary'), Buffer.from(this.pw_salt, 'binary'), 1000, 64, 'sha256').toString('hex');
};
  
userSchema.methods.isCorrectPassword = function(password: string) {
    const hash = crypto.pbkdf2Sync(Buffer.from(password, 'binary'), Buffer.from(this.pw_salt, 'binary'), 1000, 64, 'sha256').toString('hex');
    return this.pw_hash === hash;
};

// TODO: Need to include more uniqueness in the payload to make it more secure
userSchema.methods.generateToken = function() {
    return jwt.sign(
        {
            _id: this._id,
            username: this.username,
        },
        priv_key,
        {
            algorithm: "ES256",
            expiresIn: "7 days"
        }
    );
};

export default mongoose.model<IUser>('User', userSchema);
