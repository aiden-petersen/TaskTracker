import crypto from 'crypto';
import fs from 'fs';
import jwt from 'jsonwebtoken';
import mongoose, { Document, Schema } from 'mongoose';

let privKey: string;
if (!process.env.JWT_SECRET_PATH) {
  // No secret, we cannot proceed
  // TODO: need a better way to handle these fatal errors
  // console.log might not get printed
  console.log('Error: JWT_SECRET_PATH environment variable needs to be set');
  process.exit(1);
} else {
  const secretKeyPath: string = process.env.JWT_SECRET_PATH;
  privKey = fs.readFileSync(secretKeyPath, 'utf8');
}
// Needs to be a 256 bit priv key generated by openssl

export interface IUser extends Document {
  username: string;
  pwHash: string;
  pwSalt: string;
  generateToken: () => string;
  setPassword: (password: string) => void;
  isCorrectPassword: (password: string) => boolean;
}

const userSchema: Schema = new Schema({
  pwHash: {
    required: true,
    type: String
  },
  pwSalt: {
    required: true,
    type: String
  },
  username: {
    required: true,
    type: String,
    unique: true
  }
});

userSchema.methods.setPassword = function(password: string) {
  this.pwSalt = crypto.randomBytes(16).toString('hex');
  this.pwHash = crypto
    .pbkdf2Sync(
      Buffer.from(password, 'binary'),
      Buffer.from(this.pwSalt, 'binary'),
      1000,
      64,
      'sha256'
    )
    .toString('hex');
};

userSchema.methods.isCorrectPassword = function(password: string) {
  const hash = crypto
    .pbkdf2Sync(
      Buffer.from(password, 'binary'),
      Buffer.from(this.pwSalt, 'binary'),
      1000,
      64,
      'sha256'
    )
    .toString('hex');
  return this.pwHash === hash;
};

// TODO: Need to include more uniqueness in the payload to make it more secure
userSchema.methods.generateToken = function() {
  return jwt.sign(
    {
      _id: this._id,
      username: this.username
    },
    privKey,
    {
      algorithm: 'ES256',
      expiresIn: '7 days'
    }
  );
};

export default mongoose.model<IUser>('User', userSchema);
